import prisma from "@/lib/db/db"
import { CommunitySchema } from "@/lib/validations/admin/createCommunity"
import { NextRequest, NextResponse } from "next/server"
import bcrypt from "bcrypt"
import { getAuthSession } from "@/lib/auth"

// export async function GET() {
//     try {
//         const communities = await prisma.community.findMany({
//             include: {
//                 user: true
//             }
//         })

//         return new NextResponse(JSON.stringify(communities))
//     } catch (error) {
//         return new NextResponse('Could not fetch communities' + error, { status: 500 })
//     }
// }

export async function POST(req: NextRequest) {
    const currentYear = new Date().getFullYear()
    const session = await getAuthSession()

    if (session?.user.role !== "ADMIN") return new Response("Unauthorized", { status: 401 })
    
    try {

        const body = await req.json()

        const { email, name, middleName, lastName, communityName } = CommunitySchema.parse(body)

        let counter = await prisma.employeeIdCounter.findUnique({
            where: {year: currentYear}
        })

        
        // Checking of existing emails
        const emailExist = await prisma.user.findFirst({
            where:{
                email
            }
        })
        
        if(emailExist) return new NextResponse(`${email} already exists`, {status: 400})
        
        // Checking of existing community
        const communityExist = await prisma.community.findFirst({
            where: {
                name: communityName
            }
        })
        
        if (communityExist) return new NextResponse(`${communityName} community already exists`, { status: 402 })
        
        // hardcodedPassword = autogenerated based on community name
        const password = `${communityName}@Agr3eN`
        
        const hashedPassword = await bcrypt.hash(password, 12)

        if(!counter) {
            counter = await prisma.employeeIdCounter.create({
                data: {
                    year: currentYear,
                    counter: 1,
                }
            })
        } else {
            counter = await prisma.employeeIdCounter.update({
                where: {year: currentYear},
                data: {counter: counter.counter + 1}
            })
        }

        const formattedId = `${currentYear.toString().slice(-2)}-${counter.counter.toString().padStart(4, '0')}`

        const user = await prisma.user.create({
            data: {
                name,
                EmployeeId: formattedId,
                email,
                middleName,
                lastName,
                role: "EMPLOYEE",
                hashedPassword
            }
        })

        await prisma.community.create({
            data:{
                name: communityName,
                userId: user.id,
            }
        })

        // await prisma.community.create({
        //     data: {
        //         name,
        //         user: {
        //             connect: {
        //                 id: users
        //             }
        //         }
        //     }
        // })

        return new NextResponse(`Successfully created ${communityName} community!`)
    } catch (error) {
        return new NextResponse('Could not create community' + error, { status: 500 })
    }
}